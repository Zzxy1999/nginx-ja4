--- /tmp/openssl-OpenSSL_1_1_1h/include/openssl/ssl.h	2020-09-22 20:55:07.000000000 +0800
+++ include/openssl/ssl.h	2025-09-04 16:04:19.751675866 +0800
@@ -1808,6 +1808,7 @@
 size_t SSL_client_hello_get0_compression_methods(SSL *s,
                                                  const unsigned char **out);
 int SSL_client_hello_get1_extensions_present(SSL *s, int **out, size_t *outlen);
+size_t SSL_client_hello_get_ja_data(SSL *s, unsigned char *data);
 int SSL_client_hello_get0_ext(SSL *s, unsigned int type,
                               const unsigned char **out, size_t *outlen);
 
--- /tmp/openssl-OpenSSL_1_1_1h/include/openssl/tls1.h	2020-09-22 20:55:07.000000000 +0800
+++ include/openssl/tls1.h	2025-09-04 10:33:46.750217673 +0800
@@ -131,6 +131,15 @@
 /* ExtensionType value from RFC7627 */
 # define TLSEXT_TYPE_extended_master_secret      23
 
+/* ExtensionType value from RFC6961 */
+# define TLSEXT_TYPE_status_request_v2           17
+/* [draft-ietf-tls-certificate-compression] */
+# define TLSEXT_TYPE_compress_certificate        27
+/* ExtensionType value from RFC8449 */
+# define TLSEXT_TYPE_record_size_limit           28
+/* ExtensionType value from RFC7639 */
+# define TLSEXT_TYPE_application_settings        17513
+
 /* ExtensionType value from RFC4507 */
 # define TLSEXT_TYPE_session_ticket              35
 
--- /tmp/openssl-OpenSSL_1_1_1h/ssl/ssl_lib.c	2020-09-22 20:55:07.000000000 +0800
+++ ssl/ssl_lib.c	2025-09-08 10:45:25.471001296 +0800
@@ -5148,6 +5148,163 @@
     return 0;
 }
 
+// 从ssl handshake中提取ja指纹相关数据，写入fp_ja_data中
+size_t SSL_client_hello_get_ja_data(SSL *s, unsigned char *data)
+{
+    RAW_EXTENSION *ext;
+    PACKET *groups = NULL, *formats = NULL, *algorithms = NULL, *alpn = NULL;
+    size_t num = 0, i;
+    unsigned char *ptr = data, *sni_ptr = NULL;
+
+    if (s->clienthello == NULL)
+        return 0;
+
+    // 计算长度，用于nginx侧分配空间
+    if (data == NULL) {
+        num += 14; // 版本+各个部分表示长度的字段
+        num += PACKET_remaining(&s->clienthello->ciphersuites);
+        for (i = 0; i < s->clienthello->pre_proc_exts_len; i++) {
+            ext = s->clienthello->pre_proc_exts + i;
+            if (ext->present) {
+                switch (ext->type) {
+                    case TLSEXT_TYPE_supported_groups:
+                        groups = &ext->data;
+                        break;
+                    case TLSEXT_TYPE_ec_point_formats:
+                        formats = &ext->data;
+                        break;
+                    case TLSEXT_TYPE_application_layer_protocol_negotiation:
+                        alpn = &ext->data;
+                        break;
+                    case TLSEXT_TYPE_signature_algorithms:
+                        algorithms = &ext->data;
+                        break;
+                }
+                num += 2;
+            }
+        }
+        // 各个部分packet的长度
+        if (groups) {
+            num += PACKET_remaining(groups);
+        }
+        if (formats) {
+            num += PACKET_remaining(formats);
+        }
+        if (alpn) {
+            num += PACKET_remaining(alpn);
+        }
+        if (algorithms) {
+            num += PACKET_remaining(algorithms);
+        }
+        return num;
+    }
+
+    // tls版本
+    *(uint16_t*)ptr = (uint16_t)s->clienthello->legacy_version;
+    ptr += 2;
+
+    // sni要从ext获得，不能从SSL_get_servername获得
+    sni_ptr = ptr;
+    *ptr++ = 'i';
+
+    // 加密套件的packet_data为纯加密套件列表，需要额外字节存储长度
+    num = PACKET_remaining(&s->clienthello->ciphersuites);
+    *(uint16_t*)ptr = (uint16_t)num; // 加密套件列表为空时也会写入长度0
+    ptr += 2;
+    // 有数据则写入
+    if (num > 0) {
+        memcpy(ptr, PACKET_data(&s->clienthello->ciphersuites), num);
+        ptr += num;
+    }
+
+    // 处理扩展与处理加密套件类似
+    num = 0; // 个数，非字节数
+    for (i = 0; i < s->clienthello->pre_proc_exts_len; i++) {
+        ext = s->clienthello->pre_proc_exts + i;
+        if (ext->present) {
+            num++;
+        } 
+    }
+    *(uint16_t*)ptr = (uint16_t)num * 2; // 个数转字节数...
+    ptr += 2;
+    for (i = 0; i < s->clienthello->pre_proc_exts_len; i++) {
+        ext = s->clienthello->pre_proc_exts + i;
+        if (ext->present) {
+            if (ext->received_order >= num)
+                break;
+            switch (ext->type) {
+                // 支持的椭圆曲线
+                case TLSEXT_TYPE_supported_groups:
+                    groups = &ext->data;
+                    break;
+                // 支持的椭圆曲线点格式
+                case TLSEXT_TYPE_ec_point_formats:
+                    formats = &ext->data;
+                    break;
+                // 支持的签名算法
+                case TLSEXT_TYPE_signature_algorithms:
+                    algorithms = &ext->data;
+                    break;
+                // alpn
+                case TLSEXT_TYPE_application_layer_protocol_negotiation:
+                    alpn = &ext->data;
+                    break;
+                // server_name字段用于判断sni
+                case TLSEXT_TYPE_server_name:
+                    if (sni_ptr)
+                        *sni_ptr = 'd';
+                    break;
+            }
+            // ja3按照接收顺序
+            ((uint16_t*)(ptr))[ext->received_order] = (uint16_t)ext->type;
+        }
+    }
+    ptr += num*2;
+
+    // 支持的椭圆曲线
+    if (groups && (num = PACKET_remaining(groups))) {
+        memcpy(ptr, PACKET_data(groups), num);
+        // 扩展中的packet_data前两字节为长度，这里直接覆盖
+        *(uint16_t*)ptr = (uint16_t)num;
+        ptr += num;
+    } else {
+        *(uint16_t*)ptr = 0;
+        ptr += 2;
+    }
+
+    // 支持的椭圆曲线点格式，遇上类似
+    if (formats && (num = PACKET_remaining(formats))) {
+        memcpy(ptr, PACKET_data(formats), num);
+        *ptr = (uint8_t)num; // packet_data内单字节表示长度
+        ptr += num;
+    } else {
+        *ptr++ = 0; // 保持一致
+    }
+
+    // ALPN协议
+    if (alpn && (num = PACKET_remaining(alpn))) {
+        memcpy(ptr, PACKET_data(alpn), num);
+        *(uint16_t*)ptr = (uint16_t)num;
+        ptr += num;
+    } else {
+        *(uint16_t*)ptr = 0;
+        ptr += 2;
+    }
+
+    // 签名算法
+    if (algorithms && (num = PACKET_remaining(algorithms))) {
+        memcpy(ptr, PACKET_data(algorithms), num);
+        *(uint16_t*)ptr = (uint16_t)num;
+        ptr += num;
+    } else {
+        *(uint16_t*)ptr = 0;
+        ptr += 2;
+    }
+
+    // 返回写入数据的长度
+    return ptr - data;
+}
+
 int SSL_client_hello_get0_ext(SSL *s, unsigned int type, const unsigned char **out,
                        size_t *outlen)
 {
--- /tmp/openssl-OpenSSL_1_1_1h/ssl/ssl_local.h	2020-09-22 20:55:07.000000000 +0800
+++ ssl/ssl_local.h	2025-09-04 10:33:46.751217665 +0800
@@ -715,6 +715,10 @@
     TLSEXT_IDX_cryptopro_bug,
     TLSEXT_IDX_early_data,
     TLSEXT_IDX_certificate_authorities,
+    TLSEXT_IDX_status_request_v2,
+    TLSEXT_IDX_compress_certificate,
+    TLSEXT_IDX_record_size_limit,
+    TLSEXT_IDX_application_settings,
     TLSEXT_IDX_padding,
     TLSEXT_IDX_psk,
     /* Dummy index - must always be the last entry */
--- /tmp/openssl-OpenSSL_1_1_1h/ssl/statem/extensions.c	2020-09-22 20:55:07.000000000 +0800
+++ ssl/statem/extensions.c	2025-09-04 10:37:15.961499495 +0800
@@ -374,6 +374,38 @@
         tls_construct_certificate_authorities, NULL,
     },
     {
+        TLSEXT_TYPE_status_request_v2,
+        SSL_EXT_CLIENT_HELLO,
+        NULL,
+        NULL, NULL,
+        NULL,
+        NULL, NULL,
+    },
+    {
+        TLSEXT_TYPE_compress_certificate,
+        SSL_EXT_CLIENT_HELLO,
+        NULL,
+        NULL, NULL,
+        NULL,
+        NULL, NULL,
+    },
+    {
+        TLSEXT_TYPE_record_size_limit,
+        SSL_EXT_CLIENT_HELLO,
+        NULL,
+        NULL, NULL,
+        NULL,
+        NULL, NULL,
+    },
+    {
+        TLSEXT_TYPE_application_settings,
+        SSL_EXT_CLIENT_HELLO,
+        NULL,
+        NULL, NULL,
+        NULL,
+        NULL, NULL,
+    },
+    {
         /* Must be immediately before pre_shared_key */
         TLSEXT_TYPE_padding,
         SSL_EXT_CLIENT_HELLO,
